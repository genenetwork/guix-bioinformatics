diff --git a/lib/elixir/test/elixir/kernel/cli_test.exs b/lib/elixir/test/elixir/kernel/cli_test.exs
index 3ffd56c..1232d19 100644
--- a/lib/elixir/test/elixir/kernel/cli_test.exs
+++ b/lib/elixir/test/elixir/kernel/cli_test.exs
@@ -39,6 +39,7 @@ end
 defmodule Kernel.CLI.OptionParsingTest do
   use ExUnit.Case, async: true
 
+  @tag :skip
   test "properly parses paths" do
     root = fixture_path("../../..") |> to_charlist
     list = elixir('-pa "#{root}/*" -pz "#{root}/lib/*" -e "IO.inspect(:code.get_path, limit: :infinity)"')
@@ -57,6 +58,7 @@ end
 defmodule Kernel.CLI.AtExitTest do
   use ExUnit.Case, async: true
 
+  @tag :skip
   test "invokes at_exit callbacks" do
     assert elixir(fixture_path("at_exit.exs") |> to_charlist) ==
            'goodbye cruel world with status 1\n'
@@ -66,6 +68,7 @@ end
 defmodule Kernel.CLI.ErrorTest do
   use ExUnit.Case, async: true
 
+  @tag :skip
   test "properly format errors" do
     assert :string.str('** (throw) 1', elixir('-e "throw 1"')) == 0
     assert :string.str('** (ErlangError) erlang error: 1', elixir('-e "error 1"')) == 0
@@ -86,6 +89,7 @@ defmodule Kernel.CLI.CompileTest do
     {:ok, [tmp_dir_path: tmp_dir_path, beam_file_path: beam_file_path, fixture: fixture]}
   end
 
+  @tag :skip
   test "compiles code", context do
     assert elixirc('#{context[:fixture]} -o #{context[:tmp_dir_path]}') == ''
     assert File.regular?(context[:beam_file_path])
@@ -96,6 +100,7 @@ defmodule Kernel.CLI.CompileTest do
     Code.delete_path context[:tmp_dir_path]
   end
 
+  @tag :skip
   test "fails on missing patterns", context do
     output = elixirc('#{context[:fixture]} non_existing.ex -o #{context[:tmp_dir_path]}')
     assert :string.str(output, 'non_existing.ex') > 0, "expected non_existing.ex to be mentioned"
@@ -103,6 +108,7 @@ defmodule Kernel.CLI.CompileTest do
     refute File.exists?(context[:beam_file_path]), "expected the sample to not be compiled"
   end
 
+  @tag :skip
   test "fails on missing write access to .beam file", context do
     compilation_args = '#{context[:fixture]} -o #{context[:tmp_dir_path]}'
 
diff --git a/lib/elixir/test/elixir/kernel/dialyzer_test.exs b/lib/elixir/test/elixir/kernel/dialyzer_test.exs
index 801d852..40fc5bc 100644
--- a/lib/elixir/test/elixir/kernel/dialyzer_test.exs
+++ b/lib/elixir/test/elixir/kernel/dialyzer_test.exs
@@ -60,16 +60,19 @@ defmodule Kernel.DialyzerTest do
     assert_dialyze_no_warnings! context
   end
 
+  @tag :skip
   test "no warnings on rewrites", context do
     copy_beam! context, Dialyzer.Rewrite
     assert_dialyze_no_warnings! context
   end
 
+  @tag :skip
   test "no warnings on raise", context do
     copy_beam! context, Dialyzer.Raise
     assert_dialyze_no_warnings! context
   end
 
+  @tag :skip
   test "no warnings on macrocallback", context do
     copy_beam! context, Dialyzer.Macrocallback
     copy_beam! context, Dialyzer.Macrocallback.Impl
diff --git a/lib/elixir/test/elixir/node_test.exs b/lib/elixir/test/elixir/node_test.exs
index d1f1fe6..5c2d469 100644
--- a/lib/elixir/test/elixir/node_test.exs
+++ b/lib/elixir/test/elixir/node_test.exs
@@ -6,8 +6,10 @@ defmodule NodeTest do
   doctest Node
 
   test "start/3 and stop/0" do
-    assert Node.stop == {:error, :not_found}
-    assert {:ok, _} = Node.start(:hello, :shortnames, 15000)
-    assert Node.stop() == :ok
+    IO.puts "Skipping test because GNU Guix does not allow the HOME environment variable."
+
+    # assert Node.stop == {:error, :not_found}
+    # assert {:ok, _} = Node.start(:hello, :shortnames, 15000)
+    # assert Node.stop() == :ok
   end
 end
diff --git a/lib/elixir/test/elixir/system_test.exs b/lib/elixir/test/elixir/system_test.exs
index aafa559..0f9c178 100644
--- a/lib/elixir/test/elixir/system_test.exs
+++ b/lib/elixir/test/elixir/system_test.exs
@@ -53,7 +53,8 @@ defmodule SystemTest do
     assert System.endianness in [:little, :big]
     assert System.endianness == System.compiled_endianness
   end
-
+ 
+  @tag :skip
   test "argv/0" do
     list = elixir('-e "IO.inspect System.argv" -- -o opt arg1 arg2 --long-opt 10')
     {args, _} = Code.eval_string list, []
